#include <iostream>
#include <algorithm>
using namespace std;

int dp[1000001];

int main(){
    int x; cin >> x;

    dp[0] = 0;
    dp[1] = 0;
    dp[2] = 1;
    dp[3] = 1;

    for(int i = 4; i <= x; i++){
        dp[i] = dp[i-1] + 1;
        if (i % 2 == 0){
            dp[i] = min(dp[i], dp[i/2] + 1);
        }
        if (i % 3 == 0){
            dp[i] = min(dp[i], dp[i/3] + 1);
        }
    }

    cout << dp[x];
    return 0;
}

/*dp
-----------------------------------------------
x  | 최소 연산 횟수 | 최소 연산 횟수가 나오는 과정 | dp식
2  |       1       |            2->1             | dp[2] = 1
3  |       1       |            3->1             | dp[3] = 1
4  |       2       |           4->2->1           | dp[4] = dp[2] + 1 = dp[4/2] + 1
5  |       3       |          5->4->2->1         | dp[5] = dp[4] + 1 = dp[5-1/2] + 1
6  |       2       |      6->3->1 or 6->2->1     | dp[6] = dp[3] + 1 or dp[2] + 1 = dp[6/2] + 1 or dp[6/3] + 1
7  |       3       |    7->6->3->1 or 7->6->2->1 | dp[7] = dp[6] + 1 = dp[7-1/2] + 1
8  |       3       |          8->4->2->1         | dp[8] = dp[4] + 1 = dp[8/2] + 1
9  |       2       |           9->3->1           | dp[9] = dp[3] + 1 = dp[9/3] + 1
10 |       4       |         10->9->3->1         | dp[10] = dp[9] + 1 = dp[10-1]+1
...

이러한 과정을 보면 dp[n] = min(dp[n-1/2]+1, dp[n/2]+1, dp[n/3]+1)에서 가능한데
이때, 2로 나눠지는 경우에는 dp[n-1/2]+1, dp[n/2]+1이 가능하고
3으로 나눠지는 경우에는 dp[n-1/3]+1, dp[n/3]+1이 가능하다
둘다 나눠지지 않는 경우에는 dp[n-1/2]+1인 경우가 가능하다.
*/